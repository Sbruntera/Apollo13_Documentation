\section{Beschreibung des CANSAT}


% Blockdiagramm (irgendjemand)
\subsection{Missionsüberblick}
Wir haben uns für den Satelliten überlegt, dass dieser so weit wie möglich individuell sein sollte. Daher greifen wir nicht auf das, vom Wettbewerb bereitgestelte T-Minus CanSat Kit zurück. Stattdessen haben wir uns im Detail überlegt, welche Sensoren unseren Erwartungen entsprechen und wie wir diese bestmöglich innerhalb der Dose plazieren können. Zusätzlich möchten wir nicht auf eine Cola-Dose als Hülle zurück greifen, sondern möchten auch hier unser eigenes Design erschaffen.


% 3D Skizze, Erklärung der einzelnen Bestandteile (Alexander B.)
\input {./2_Beschreibung_des_CANSAT/hardware_mechanischesDesign_doku}


% Elektrisches Vorgehen, Schaltplan, Funkverbindung (Till)
\input {./2_Beschreibung_des_CANSAT/hardware_elektrischeKonstruktion_doku}

% Programmiersprache, Entwicklungsumgebung, abschätzung Datenmenge, Programmablauf (PAP), Datenverarbeitung (Steffen)
\input {./2_Beschreibung_des_CANSAT/hardware_softwareentwurf_doku}

% Fallschirm (Alexander F.)
\input {./2_Beschreibung_des_CANSAT/hardware_bergungssystem_doku}


%ACHTUNG AB HIER ALLES AUSKOMMENTIERT

\begin {comment}

\subsubsection{Elektronische Grundlagen}
Die Berechnung von Strom im geschlossenen System wird für unser Projekt benötigt, allerdings wegen der häufigen Anwendung von Digitaltechnik eher weniger. Außerdem müssen wir die Berechnung von Wiederständen in Parallel- und Reihenschaltungen kennen und selber anwenden können.
\[
U * R = I
\]

Reihenschaltung
\[
R_{ges} = R_1 + R_2 + ... + R_n = \sum_{i=1}^{n} R_i
\]

\[
U_{ges} = U_1 + U_2 + ... + U_n
\]

\[
I_{ges} = I_1 = I_2 = ... + I_n
\]

Parrallelschaltung
\[
\frac{1}{R_{ges}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n} = \sum_{i=1}^{n} \frac{1}{R_i}
\]

\[
U_{ges} = U_1 = U_2 = ... = U_n
\]

\[
I_{ges} = I_1 + I_2 + ... I_n = \sum_{i=1}^{n} I_i
\]

Reihen und Parallelschaltungen für Stromquellen haben wir nicht in Erwägung gezogen und gehört deshalb auch nicht zu den fachlichen Grundlagen. Weiterhin gehörte zu den elektrischen Grundlagen, dass Verständnis über einfache Dioden und über mehrere digitaltechnische Technologien welches in den nächsten Abschnitten erklärt wird.

\subsubsection{Embedded System}
Ein Embedded System ist in unserem Fall der BeagleBone mithilfe vom ARM Cortex-A6 mit 1Ghz, ist ein leich modifizierte linux kernel mit Frontend installiert, dass liebevoll Angstrom genannt wurde. Um ein paar andere Beispiele für ein eingebettetes System sind etwa ein Smart TV oder ein Router, beide haben eine Art eingebettetes System, dass immer öfter auf dem Linux Kernel basiert und je nach Anwendung angepasst wurde. In unserem Fall unterstützt das BeagleBone verschiedene Technologien zum empfangen von Daten verschiedener Bauteile, wie etwa UART, I-2-C, SPI, Analog, Digital, PWM, Timer und PRU. Viele dieser Technologien sind in unserem Projekt nicht in Verwendung alle anderen Grundlagen sind unten beschrieben.

\subsubsection{Transistor-Transistor-Logik}
5V werden immer als logische 1 bezeichnet, damit ist gemeint wenn der Sensor den höchsten Messwert erreicht gibt er eine Spannung von 5V. Ist dies nicht der Fall hat der Sensor eine andere Kennkurve die zum Beispiel bei 3.3V aufhört. Allgemein wird aber Transistor-Transistor-Logik genutzt, welche 5V als logische 1 und geerdet als logische 0 ansieht, es gibt natürlich Toleranzen, diese sind aber bei verschiedenen integrierte Schaltkreisen und Mikrokontrollern unterschiedlich.

\subsubsection{Analog-to-Digital-Converter}
Andere Sensoren wie der UV-Sensor die nur über einen internen Wiederstand verfügen der sich, je nach Konzentration, an einer mathematischen Kurve orientierend, im Wert leicht verändert und dadurch die ankommende Spannung am jeweiligen Analog Pin ändert. Mithilfe eines Analog-to-Digital-Converter konvertieren wir das analoge Signal, zum Beispiel 5V, in das äquivalente digitale Signal mit der Auflösung von 12 Bits. \\

\[
2^{12} \quad = 4096
\]

\[
\frac{5V}{4096} = 0.001220703125 V
\] \\

Das bedeutet jeder 0.001220703125V kann dargestellt werden, wobei der Arduino Mega 2560 nur 10 Bits zur Verfügung stellt. \\

\[
2^{10} \quad = 1024
\]

\[
\frac{5V}{1024} = 0.0048828125V
\] \\

Der Arduino kann den Wert der am analogen Pin ankommt viel ungenauer darstellen, als das BeagleBone. 

\subsubsection{Universal-Asynchronous-Receiver-Transmitter}
UART ist eine digitale serielle Schnittstelle zum realisieren von einfachen Kommunikationen zwischen zwei Endpunkten, die Funktionsweise ist denkbar einfach. Wir nutzen in unserem Satelliten meist eine Baudrate von 9600bps, Baud ist die Schrittgeschwindigkeit oder Symbolrate, also 9600 bits per second. Für UART gibt es wie beim RJ45 Stecker TX und RX, die beim Aufbau einer Kommunikation gekreuzt werden. Transciever und Reciever. Nun wird zwischen vielen verschiedenen Arten von UART unterschieden in unserem Fall die TTL-UART Variante welche die beim Analog-to-Digital-Converter genannten 5V als logische 1 bezeichnen. \\

 

\subsubsection{Inter-Integrated-Circuit}
I-2-C ist ein serieller Datenbus der über zwei Kabel mit einer 10-Bit-Adressierung, 1024 IC's steuern kann mit einer maximalen Geschwindigkeit 5 Mbit/s. Der Sinn des Bussystems ist es mithilfe von einer Adressen einen Datensatz oder Befehl nur an den gewünschten Empfänger zu senden, obwohl nur eine Datenleitung genutzt wird, eine Art Master/Slave System. Der Master sagt wer wann zu sprechen hat und welche Befehle von wem zu empfangen sind.

\subsubsection{Python}
Als Programmiersprache zur Programmierung des Beaglebone Black’s, haben wir uns für die Programmiersprache Python entschieden. Es wäre zwar ebenfalls möglich gewesen den Mikrocontroller mit den Sprachen JavaScript, Java, C, C++, C\# und vielen weiteren Sprachen zu programmieren, da es sich bei dem Beaglebone um ein embedded-System handelt, welches praktisch alle Programmiersprachen unterstützt, sofern entsprechende Librarys existieren. Allerdings haben wir uns aufgrund der Tatsache, dass Python im Gegensatz zu Java nicht objektorientiert geschrieben werden muss, und wir auf der Hardwareseite möglichst auf objektorientierte Programmierung verzichten wollen, da sie nicht nötig ist, für Python entschieden. Ein weiteres wichtiges Argument war die gute Python-Library, welche von einer großen Community permanent gewartet und aktualisiert wird.
\end {comment}
