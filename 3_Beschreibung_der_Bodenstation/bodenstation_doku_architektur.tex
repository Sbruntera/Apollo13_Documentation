\subsubsection{Architektur}
Insgesamt ist die Architektur der Applikation um das GUI-Framework Netbeans Platform aufgebaut, da es die Nutzung von bestimmten Architekturen einfacher macht, mit Netbeans Platform zu arbeiten und alle Features von Netbeans Platform zu nutzen.

Insgesamt ist die Applikation in Module und Pakete aufgeteilt. Während normale Java-Projekte normalerweise lediglich in Pakete aufgeteilt sind, werden in Netbeans Platform die einzelnen Komponenten in Module aufgeteilt. Jedes Modul verhält sich hierbei wie ein einzelnes Projekt, welches dann vom Hauptprojekt eingebunden wird. Dies fördert generell die Wiederverwendung der einzelnen Module, da sich Entwickler darüber Gedanken machen müssen, wie die einzelnen Module in verschiedenen Umgebungen verwendet werden können. \\
Den Aufbau der Netbeans Platform Modularchitektur ist auch im Anhang unter Abbildung \ref{nbp_modularchitektur} zu finden.

Anfänglich haben wir jeden einzelnen Teilkomponenten in ein Modul ausgelagert, was jedoch zu einer Menge Merge-Konflikten geführt hat, da Netbeans Platform für jedes einzelne Modul eigene Konfigurationsdateien generiert, über welche man nur schwer den Überblick behalten kann. Diese anfängliche Architektur wurde schlussendlich in eine Architektur mit nur drei Modulen umgewandelt: API, Core und GUI. \\
Das Core-Modul enthält die Programmlogik, welche sich hauptsächlich mit der Verarbeitung der Daten innerhalb der Input-Pipeline beschäftigt. \\
Das GUI-Modul enthält die verschiedenen GUI-Komponenten, welche sowohl Teil der allgemeinen Benutzeroberfläche sind als auch Visualisierungskomponenten darstellen. \\
Innerhalb des API-Moduls befinden sich Interfaces und Utility-Klassen, welche sowohl vom Core-Modul als auch vom GUI-Modul genutzt werden. Das Core-Modul implementiert hierbei die Interfaces aus dem API-Modul, während das GUI-Modul die Programmlogik im Core-Modul lediglich entkoppelt über die Interfaces des API-Moduls anspricht. \\
Diese Architektur zeigt bereits, dass das GUI-Modul vom Core-Modul entkoppelt ist. Diese Entkopplung trägt stark zu der Erweiterbarkeit der Applikation bei. Die Architektur ähnelt hierbei der standardmäßigen ``Model, View, Controller''-Architektur, jedoch scheint innerhalb der Architektur kein Controller vorhanden zu sein. Auf den ersten Blick gesehen scheint es so, als spreche das GUI-Modul das Core-Modul direkt über das API-Modul an, jedoch sorgt Netbeans-Platform dafür, dass dem nicht so ist. Die von Netbeans Platform bereitgestellten Lookups, welche eine weitere Ebene der Entkoppelung darstellen, erfüllen in der Applikation die Aufgabe des Controllers. Durch die Lookups wird innerhalb des GUI-Moduls eine passende Klasse innerhalb des Core-Moduls über das Interface der Klasse im API-Modul geladen. Dank den Lookups und den Interfaces im API-Modul besteht absolut keinerlei Kopplung zwischen den einzelnen Klassen und Modulen: Die GUI kennt das Model nicht und das Model kennt die GUI nicht. \\
Die Modularchitektur der Bodenstation ist ebenfalls im Anhang unter Abbildung \ref{station_modularchitektur} zu finden.

Weitergehend relevant ist die Architektur der Input-Pipeline, welche in der Bodenstation dafür zuständig ist, die empfangenen Daten zu verarbeiten, bevor sie an die jeweiligen Komponenten zur Endbehandlung der Daten weitergeleitet werden. Insgesamt wandelt die Input-Pipeline die aus einem Datenstream empfangenen Daten in einen Map-Datentypen um, welcher genau einem Datensatz entspricht, und leitet die Daten an alle registrierten Empfänger weiter. Die Schlüssel der Map entsprechen den Schlüsseln der Datenübertragung und die Werte der Map entsprechen den Daten, welche zu dem jeweiligen Schlüssel gehören. Zusätzlich zu dieser Datentransformation sorgt die Input-Pipeline ebenfalls dafür, dass fehlerhafte und fehlende Daten herausgefiltert und über die zuletzt erhaltenen Daten abgeflacht werden. \\
Die Input-Pipeline ist Push-basiert, was bedeutet, dass jeder Komponent immer die verarbeiteten Daten an den nächsten Komponenten weitergibt, damit zwischen den einzelnen Komponenten nicht gepollt werden muss. Die Input-Pipeline besteht insgesamt aus vier Komponenten. Am Anfang der Input-Pipeline steht eine DataSource, welche die Daten von einer beliebigen Datenquelle via Polling bezieht und die ausgelesenen Daten an ein DataFormat weitergibt. DataFormat sorgt dafür, dass der von einer DataSource empfangene String mit dem jeweiligen Übertragungsformat, zum Beispiel JSON, geparst wird, um so einen Datensatz als Map zu erzeugen. DataFormat leitet die geparsten Daten dann an einen DataProvider weiter, welcher die fehlenden Daten herausfiltert, abflacht, und an alle bei ihm registrierten Empfänger weiterleitet. Bei der Abflachung der Daten merkt sich der DataProvider immer die zuletzt empfangenen Daten und ergänzt fehlende Daten mit den zuletzt empfangenen Daten. Sind noch keine Daten empfangen worden, so werden die Daten mit Default-Werten ergänzt. \\
Insgesamt wird die Input-Pipeline von einer DataPipeline umschlossen, welche die Input-Pipeline zusammenbaut, die verschiedenen Komponenten austauscht, die verschiedenen Empfänger beim DataProvider registriert und allgemein als Schnittstelle zu den verschiedenen Empfängern und dem GUI-Modul fungiert. \\
Der Aufbau der Input-Pipeline ist ebenfalls im Anhang unter Abbildung \ref{inputpipeline} zu finden.